#pragma once
#ifndef _BLF_
#define _BLF_


#include <Windows.h>




#pragma comment(lib, "Clfsw32.lib")




//https://github.com/ionescu007/clfs-docs

/*
//clfs.h
typedef struct _CLFS_NODE_ID
{
	ULONG   cType;                                      // CLFS node type.
	ULONG   cbNode;                                     // CLFS node size.
} CLFS_NODE_ID, * PCLFS_NODE_ID;
*/

//CLFS_NODE_ID node type | CLFS 数据结构 
//https://github.com/ionescu007/clfs-docs#node-types
const ULONG CLFS_NODE_TYPE_FCB = 0xC1FDF001;
const ULONG CLFS_NODE_TYPE_VCB = 0xC1FDF002;
const ULONG CLFS_NODE_TYPE_CCB = 0xC1FDF003;
const ULONG CLFS_NODE_TYPE_REQ = 0xC1FDF004;
const ULONG CLFS_NODE_TYPE_CCA = 0xC1FDF005;
const ULONG CLFS_NODE_TYPE_SYMBOL = 0xC1FDF006;
const ULONG CLFS_NODE_TYPE_CLIENT_CONTEXT = 0xC1FDF007;
const ULONG CLFS_NODE_TYPE_CONTAINER_CONTEXT = 0xC1FDF008;
const ULONG CLFS_NODE_TYPE_SHARED_SECURITY_CONTEXT = 0xC1FDF00D;
const ULONG CLFS_NODE_TYPE_DEVICE_EXTENSION = 0xC1FDF009;
const ULONG CLFS_NODE_TYPE_MARSHALING_AREA = 0xC1FDF00A;
const ULONG CLFS_NODE_TYPE_ARCHIVE_CONTEXT = 0xC1FDF00C;
const ULONG CLFS_NODE_TYPE_SCAN_CONTEXT = 0xC1FDF00E;
const ULONG CLFS_NODE_TYPE_LOG_READ_IOCB = 0xC1FDF00F;
const ULONG CLFS_NODE_TYPE_LOG_WRITE_IOCB = 0xC1FDF010;



//https://github.com/ionescu007/clfs-docs#log-blocks-and-sectors
const ULONG CLFS_SECTOR_SIZE = 0x00000200;
const UCHAR SECTORSHIFT = 9;

//扇区属性  [Sector Block Type] 
const UCHAR SECTOR_BLOCK_NONE = 0x00;
const UCHAR SECTOR_BLOCK_DATA = 0x04;
const UCHAR SECTOR_BLOCK_OWNER = 0x08;
const UCHAR SECTOR_BLOCK_BASE = 0x10;
//附加标志来标识第一个扇区和/或最后一个扇区
const UCHAR SECTOR_BLOCK_END = 0x20;
const UCHAR SECTOR_BLOCK_BEGIN = 0x40;

//节签名格式 [Sector Block Type][Usn]


typedef  UCHAR  CLFS_CLIENT_ID;

//_CLFS_LOG_BLOCK_HEADER flags
const ULONG CLFS_BLOCK_RESET = 0x00000000;
const ULONG CLFS_BLOCK_ENCODED = 0x00000001;
const ULONG CLFS_BLOCK_DECODED = 0x00000002;
const ULONG CLFS_BLOCK_LATCHED = 0x00000004;
const ULONG CLFS_BLOCK_TRUNCATE_DISCARD = 0x00000008;

const UCHAR MAJORVERSION = 0x15;
const UCHAR MINORVERSION = 0x00;

//日志块标头
typedef struct _CLFS_LOG_BLOCK_HEADER
{
	UCHAR MajorVersion;  //主版本号 0x15       offset:0
	UCHAR MinorVersion;  //次版本号 0x00       offset:1
	UCHAR Usn;   //节签名格式的Usn   更新序列号  每次完成一致写入时，更新计数都会递增       offset:2
	CLFS_CLIENT_ID ClientId; //对应于与块关联的客户端标识符，也称为流标识符。对于元数据块，例如基本日志文件中的元数据块，这是无关紧要的，并且将始终设置为0.
	USHORT TotalSectorCount;  //包括初始和截断后的扇区数。对于基本日志文件，这些数字将始终固定       offset:4
	USHORT ValidSectorCount;  //包括初始和截断后的扇区数。对于基本日志文件，这些数字将始终固定       offset:6
	ULONG Padding;		//       offset:8
	ULONG Checksum; //日志块内容的校验和  //       offset:12
	ULONG Flags;   //       offset:16
	CLFS_LSN CurrentLsn;  //基本块的当前 LSN和下一个 LSN始终设置为CLFS_LSN_INVALID       offset:20
	CLFS_LSN NextLsn;  //基本块的当前 LSN和下一个 LSN始终设置为CLFS_LSN_INVALID         offset:28
	ULONG RecordOffsets[16];  //第一个记录偏移量总是在sizeof(CLFS_LOG_BLOCK_HEADER). 没有其他记录偏移量用于基本块       offset:36
	ULONG SignaturesOffset; //签名偏移对应于一个内存数组，用于存储所有被扇区签名覆盖的扇区字节  这个偏移针对当前结构的起始地址
	//该数组位于最后一个扇区，并且必须足够大以容纳TotalSectorCount * overwritten sector data字节，记住为最后一个扇区本身的 ULONG 对齐签名数据留出空间。
	 //从磁盘读取基本日志文件时，解析这个数组很关键，每取 2 个字节并将它们覆盖在每个相应扇区的签名字节之上（恢复原始数据字节）
} CLFS_LOG_BLOCK_HEADER, * PCLFS_LOG_BLOCK_HEADER;


//基本日志文件由6个不同的元数据块组成，它们都是前面显示的基本日志块的扩展，每个元数据块只包含一条记录
//元数据块计数
const USHORT CLFS_METADATA_BLOCK_COUNT = 6;


//元数据块类型  CClfsBaseFilePersisted::CreateImage可用于查看各种元数据块是如何在基本日志文件中创建、写入和刷新的。
typedef enum _CLFS_METADATA_BLOCK_TYPE
{
	ClfsMetaBlockControl,  //控制元数据块,包含控制记录,包含有关布局、扩展区域和截断区域的信息
	ClfsMetaBlockControlShadow,  //控制元数据块副本
	ClfsMetaBlockGeneral,  //通用元数据块	,包含基本记录	，包含符号表，这些符号表存储与基本日志文件关联的各种客户端、容器和安全上下文的信息，以及这些的记帐信息。
	ClfsMetaBlockGeneralShadow, //通用元数据块副本
	ClfsMetaBlockScratch,  //临时元数据块	,包含截断记录，包含有关因截断操作而需要更改扇区的每个客户端（流）的信息，以及相关扇区字节的更改。
	ClfsMetaBlockScratchShadow //临时元数据块副本
} CLFS_METADATA_BLOCK_TYPE, * PCLFS_METADATA_BLOCK_TYPE;

//元数据记录头
typedef struct _CLFS_METADATA_RECORD_HEADER
{
	ULONGLONG ullDumpCount;  //此转储计数对应于元数据记录的一种序列号，可用于识别记录的最新或“最新鲜”副本。
} CLFS_METADATA_RECORD_HEADER, * PCLFS_METADATA_RECORD_HEADER;


//元数据块=[日志块标头 + 记录]



//*************控制元数据块**************控制记录**************

//控制记录或控制元数据块占用扇区数
const USHORT CLFS_CONTROL_BLOCK_RAW_SECTORS = 2;


//控制记录 - eExtendState  扩展上下文
//与 CLFS 日志扩展相关,此数据在内存中可能不为零，但对于磁盘上稳定的基本日志文件可能为零
typedef enum _CLFS_EXTEND_STATE
{
	ClfsExtendStateNone,
	ClfsExtendStateExtendingFsd,
	ClfsExtendStateFlushingBlock
} CLFS_EXTEND_STATE, * PCLFS_EXTEND_STATE;


//控制记录 - ullMagicValue
const ULONGLONG CLFS_CONTROL_RECORD_MAGIC_VALUE = 0xC1F5C1F500005F1C;

//控制记录 - Version
const UCHAR MAJORVERSION_CONTROL = 0x01;



//CLFS_TRUNCATE_CONTEXT - eTruncateState   截断状态枚举
typedef enum _CLFS_TRUNCATE_STATE
{
	ClfsTruncateStateNone,
	ClfsTruncateStateModifyingStream,
	ClfsTruncateStateSavingOwner,
	ClfsTruncateStateModifyingOwner,
	ClfsTruncateStateSavingDiscardBlock,
	ClfsTruncateStateModifyingDiscardBlock
} CLFS_TRUNCATE_STATE, * PCLFS_TRUNCATE_STATE;

//控制记录 - cxTruncate  截断上下文
//在磁盘上一般为0
typedef struct _CLFS_TRUNCATE_CONTEXT
{
	CLFS_TRUNCATE_STATE eTruncateState;
	CLFS_CLIENT_ID cClients;  //被截断的客户端数量
	CLFS_CLIENT_ID iClient;  //被截断的精确客户端索引
	CLFS_LSN lsnOwnerPage;  //正在处理的当前所有者页面的LSN  ；如果状态为 ClfsTruncateStateSavingOwner ClfsTruncateStateModifyingOwner
	CLFS_LSN lsnLastOwnerPage;  //最后一个所有者页面的 LSN  ；如果状态为 ClfsTruncateStateSavingOwner ClfsTruncateStateModifyingOwner
	ULONG cInvalidSector;  //当前正在处理的扇区索引标识   ; 如果状态为 ClfsTruncateStateSavingDiscardBlock ClfsTruncateStateModifyingDiscardBlock
} CLFS_TRUNCATE_CONTEXT, * PCLFS_TRUNCATE_CONTEXT;


//控制记录 - rgBlocks[ANYSIZE_ARRAY] 数组中的元素结构
typedef struct _CLFS_METADATA_BLOCK
{
	union
	{
		PUCHAR pbImage;  //在内存中，一个附加字段pbImage用于存储指向内核模式内存中数据的指针；磁盘上应为0
		ULONGLONG ullAlignment;
	};
	ULONG cbImage;  //相应块的大小
	ULONG cbOffset;  //偏移量，从控制元数据块（即：基本日志文件中的第一个扇区）开始，在哪里可以找到元数据块
	CLFS_METADATA_BLOCK_TYPE eBlockType;  //元数据块类型
} CLFS_METADATA_BLOCK, * PCLFS_METADATA_BLOCK;



//控制记录
typedef struct _CLFS_CONTROL_RECORD
{
	CLFS_METADATA_RECORD_HEADER hdrControlRecord;
	ULONGLONG ullMagicValue;
	UCHAR Version;
	CLFS_EXTEND_STATE eExtendState;  //扩展上下文
	USHORT iExtendBlock;  //正在扩展的块的索引
	USHORT iFlushBlock;  //正在刷新的块，通常是影子块
	ULONG cNewBlockSectors; //存储新块的扇区大小
	ULONG cExtendStartSectors;  //扩展操作之前的原始扇区大小
	ULONG cExtendSectors;  //添加（扩展）的扇区数
	CLFS_TRUNCATE_CONTEXT cxTruncate;  //截断上下文
	USHORT cBlocks;  //rgBlocks数组的原数据块个数
	ULONG cReserved;  //
	CLFS_METADATA_BLOCK rgBlocks[ANYSIZE_ARRAY];  //元数据块数组，一般个数为6
} CLFS_CONTROL_RECORD, * PCLFS_CONTROL_RECORD;





//*************通用元数据块**************基本记录**************
//基本记录包含有关与基本日志文件关联的客户端和容器的信息，以及它们的相关上下文
//每个容器的共享安全上下文也存储在这里
//还存在一些状态信息
//https://github.com/ionescu007/clfs-docs#base-record


//Clients 客户端
//Clients是CLFS日志的用户，对于基本日志文件，最初存在一个元数据客户端
//最大Clients数量
const UCHAR MAX_CLIENTS_DEFAULT = 124;
//Clients ID最大值，每个Client都有一个标识符
const UCHAR HIGHEST_CLIENT_ID = 96;
//Clients符号表的桶大小，可以通过Clients符号表查找所有Client
const UCHAR CLIENT_SYMTBL_SIZE = 11;

//Containers 容器
//容器是保存受 CLFS 语义约束的特定数据的日志记录的实体
//支持的最大容器数
const ULONG MAX_CONTAINERS_DEFAULT = 1024;
//容器符号表的桶大小，可以在容器符号表中查找容器
const UCHAR CONTAINER_SYMTBL_SIZE = 11;

//Shared Security Context 共享安全上下文
//共享安全上下文用于存储由基本日志文件描述的容器的安全描述符
//共享安全上下文的桶大小
const UCHAR SHARED_SECURITY_SYMTBL_SIZE = 11;

//基本记录头 - eLogState
typedef UCHAR CLFS_LOG_STATE, * PCLFS_LOG_STATE;
const CLFS_LOG_STATE CLFS_LOG_UNINITIALIZED = 0x01;
const CLFS_LOG_STATE CLFS_LOG_INITIALIZED = 0x02;
const CLFS_LOG_STATE CLFS_LOG_ACTIVE = 0x04;
const CLFS_LOG_STATE CLFS_LOG_PENDING_DELETE = 0x08;
const CLFS_LOG_STATE CLFS_LOG_PENDING_ARCHIVE = 0x10;
const CLFS_LOG_STATE CLFS_LOG_SHUTDOWN = 0x20;
const CLFS_LOG_STATE CLFS_LOG_MULTIPLEXED = 0x40;
const CLFS_LOG_STATE CLFS_LOG_SECURE = 0x80;

//Base Record Header 基本记录头
//基本记录以_CLFS_BASE_RECORD_HEADER开头
typedef struct _CLFS_BASE_RECORD_HEADER
{
	CLFS_METADATA_RECORD_HEADER hdrBaseRecord;  //元数据记录头
	CLFS_LOG_ID cidLog;  //日志标识符，在日志创建时随机生成的UUID  
	ULONGLONG rgClientSymTbl[CLIENT_SYMTBL_SIZE];    //客户端符号表（即哈希表），每个条目都是哈希符号的 64 位偏移量  //针对当前结构的起始的偏移 
	//遍历整个数组，非0值为偏移
	ULONGLONG rgContainerSymTbl[CONTAINER_SYMTBL_SIZE];//容器符号表（即哈希表），每个条目都是哈希符号的 64 位偏移量  //针对当前结构的起始的偏移 
	//遍历整个数组，非0值为偏移
	ULONGLONG rgSecuritySymTbl[SHARED_SECURITY_SYMTBL_SIZE];//安全上下文符号表（即哈希表），每个条目都是哈希符号的 64 位偏移量
	ULONG cNextContainer; //下一个可用容器索引
	CLFS_CLIENT_ID cNextClient; //下一个可用客户端索引
	ULONG cFreeContainers;  //空闲容器计数,似乎从未被使用过
	ULONG cActiveContainers;  //活动容器计数
	ULONG cbFreeContainers;  //清零且从未使用过
	ULONG cbBusyContainers;  //清零且从未使用过
	ULONG rgClients[MAX_CLIENTS_DEFAULT];  //指向每个客户端上下文的 32 位偏移数组，这些偏移量直接指向适当的上下文结构  //针对当前结构的起始的偏移
	//从头遍历数组，为0跳出
	ULONG rgContainers[MAX_CONTAINERS_DEFAULT];  //指向每个容器上下文的 32 位偏移数组，这些偏移量直接指向适当的上下文结构  //针对当前结构的起始的偏移 
	//从头遍历数组，为0跳出
//该数组应具有与上述字段cActiveContainers相同的条目数
	ULONG cbSymbolZone;  //包含所有符号（3种类型的上下文）的符号区域的大小，即新符号的下一个可用偏移量
	ULONG cbSector;  //未使用
	USHORT bUnused; //未使用
	CLFS_LOG_STATE eLogState;    //日志的当前状态
	UCHAR cUsn;  //用于容器的USN，匹配该容器上下文的当前USN
	UCHAR cClients;  //存储在基本日志文件中的客户端数量，应该匹配rgClients数组的条目数量
} CLFS_BASE_RECORD_HEADER, * PCLFS_BASE_RECORD_HEADER;



//符号
//类型 CLFS_NODE_TYPE_SYMBOL
//基本日志文件中的客户端、容器和共享安全上下文由符号表示
//CLFS_BASE_RECORD_HEADER中的rgClientSymTbl、rgContainerSymTbl、rgSecuritySymTbl的每个64位偏移量都指向如下结构
typedef struct _CLFSHASHSYM
{
	CLFS_NODE_ID cidNode;
	ULONG ulHash;  //哈希代码，使用Hollub版本UNICODE_STRING的PJW哈希计算得出的，该字符串存储符号的名称，每个字母大写
	ULONG cbHash;  //符号数据的大小（不带标头）
	ULONGLONG ulBelow; //在哈希冲突的情况下， ulBelow是前个符号的64位偏移量，将冲突视为二叉搜索树，如果没有冲突，这些字段将被清零
	ULONGLONG ulAbove; //在哈希冲突的情况下， ulAbove是前个符号的64位偏移量，将冲突视为二叉搜索树。如果没有冲突，这些字段将被清零
	LONG cbSymName;  //符号全名的偏移量
	LONG cbOffset;  //数据开始位置的偏移量
	BOOLEAN fDeleted;  //指示符号是否已被删除
} CLFSHASHSYM, * PCLFSHASHSYM;

//客户端上下文
//标识日志文件的用户或客户端，在每个基本日志文件中总会创建至少一个这样的元数据客户端
//类型 CLFS_NODE_TYPE_CLIENT_CONTEXT
typedef struct _CLFS_CLIENT_CONTEXT
{
	CLFS_NODE_ID cidNode;
	CLFS_CLIENT_ID cidClient;
	USHORT fAttributes;  //对应于与基本日志文件关联的标志集FILE_ATTRIBUTE（例如System和Hidden）
	ULONG cbFlushThreshold;   //来自注册表项HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\CLFS\Parameters\和
	//REG_DWORD值FlushThreshold，通常设置为40000
	ULONG cShadowSectors;
	ULONGLONG cbUndoCommitment;
	LARGE_INTEGER llCreateTime;  //创建时间
	LARGE_INTEGER llAccessTime; //访问时间
	LARGE_INTEGER llWriteTime;  //写入时间
	CLFS_LSN lsnOwnerPage;  //各种LSN,磁盘中通常为0或CLFS_INVALID_LSN
	CLFS_LSN lsnArchiveTail;
	CLFS_LSN lsnBase;
	CLFS_LSN lsnLast;
	CLFS_LSN lsnRestart;
	CLFS_LSN lsnPhysicalBase;
	CLFS_LSN lsnUnused1;
	CLFS_LSN lsnUnused2;
	CLFS_LOG_STATE eState;
	union
	{
		HANDLE hSecurityContext;  //内存中,指向客户端共享安全上下文的偏移量,基本记录头中不存在共享安全上下文数组
		ULONGLONG ullAlignment;
	};
} CLFS_CLIENT_CONTEXT, * PCLFS_CLIENT_CONTEXT;
//该结构后面紧跟着客户端名，客户端即BLF文件


#include <clfsw32.h>
typedef char CClfsContainer; //虚假定义
typedef UCHAR CLFS_USN;//虚假定义
//容器上下文
//类型 CLFS_NODE_TYPE_CONTAINER_CONTEXT
typedef struct _CLFS_CONTAINER_CONTEXT
{
	CLFS_NODE_ID cidNode;
	ULONGLONG cbContainer;  //容器的64位大小
	CLFS_CONTAINER_ID cidContainer;  //容器标识符，从0开始
	CLFS_CONTAINER_ID cidQueue;  //队列中的标识符，如果容器在容器队列中
	union
	{
		CClfsContainer* pContainer;  //磁盘中应始终清零，但在内存中，它实际上包含指向运行时描述容器的类的内核指针（内核对象）
		ULONGLONG ullAlignment;
	};
	CLFS_USN usnCurrent; //应于容器的USN，它应该基于cUsn基本记录头单调递增
	CLFS_CONTAINER_STATE eState;  //容器状态,在磁盘上容器状态通常是ClfsContainerInactive
	ULONG cbPrevOffset;  //未使用过
	ULONG cbNextOffset;  //未使用过
} CLFS_CONTAINER_CONTEXT, * PCLFS_CONTAINER_CONTEXT;
//该结构后面紧跟着容器名


//共享安全上下文
//类型 CLFS_NODE_TYPE_SHARED_SECURITY_CONTEXT
//通常只能在内存表示中找到，而永远不会在磁盘上找到
typedef struct _CLFS_SHARED_SECURITY_CONTEXT
{
	CLFS_NODE_ID cidNode;
	ULONG cRef;  //存储使用共享上下文的调用者的数量
	ULONG cRefActive;  //跟踪与共享上下文关联的安全描述符
	ULONG coffDescriptor;  //指向安全描述符字节本身，通常应始终设置为offsetof(CLFS_SHARED_SECURITY_CONTEXT, rgbSecurityDescriptor);
	ULONG cbDescriptor;  //安全描述符的大小
	UCHAR rgbSecurityDescriptor[ANYSIZE_ARRAY];  //SECURITY_DESCRIPTOR数组
} CLFS_SHARED_SECURITY_CONTEXT, * PCLFS_SHARED_SECURITY_CONTEXT;


//*************临时元数据块**************截断记录**************
//截断记录在日志截断期间使用


//截断记录头
typedef struct _CLFS_TRUNCATE_RECORD_HEADER
{
	CLFS_METADATA_RECORD_HEADER hdrBaseRecord;
	ULONG coffClientChange;   //第一个结构的偏移量
	ULONG coffOwnerPage;  //第一个所有者页面的偏移量
} CLFS_TRUNCATE_RECORD_HEADER, * PCLFS_TRUNCATE_RECORD_HEADER;


//CLFS_TRUNCATE_CLIENT_CHANGE - rgSectors 
typedef struct _CLFS_SECTOR_CHANGE
{
	ULONG iSector;  //目标扇区索引
	ULONG ulUnused;
	BYTE rgbSector[CLFS_SECTOR_SIZE];  //要写入的新扇区数据
} CLFS_SECTOR_CHANGE, * PCLFS_SECTOR_CHANGE;


//客户端更改描述符
typedef struct _CLFS_TRUNCATE_CLIENT_CHANGE
{
	CLFS_CLIENT_ID cidClient;  //正在修改哪个客户端标识符（流标识符）
	CLFS_LSN lsn; //替换块的物理LSN？
	CLFS_LSN lsnClient;  //替换块的虚拟LSN？
	CLFS_LSN lsnRestart;  // 包含新重启区域的 LSN
	USHORT cLength;   //新替换块的大小
	USHORT cOldLength;  //旧块的大小
	ULONG cSectors;  // rgSectors 数组大小？
	CLFS_SECTOR_CHANGE rgSectors[ANYSIZE_ARRAY];
} CLFS_TRUNCATE_CLIENT_CHANGE, * PCLFS_TRUNCATE_CLIENT_CHANGE;







//*************内核类表示**************

////CLFS 内存类
////一旦在内存中，CLFS基本日志文件由类CClfsBaseFile表示
//struct _CClfsBaseFile
//{
//    ULONG m_cRef;
//    PUCHAR m_pbImage;
//    ULONG m_cbImage;
//    PERESOURCE m_presImage;
//    USHORT m_cBlocks;
//    PCLFS_METADATA_BLOCK m_rgBlocks;
//    PUSHORT m_rgcBlockReferences;
//    CLFSHASHTBL m_symtblClient;
//    CLFSHASHTBL m_symtblContainer;
//    CLFSHASHTBL m_symtblSecurity;
//    ULONGLONG m_cbContainer;
//    ULONG m_cbRawSectorSize;
//    BOOLEAN m_fGeneralBlockReferenced;
//} CClfsBaseFile, * PCLFSBASEFILE;
//
//
//
////内存类中的HASH表
//typedef struct _CLFSHASHTBL
//{
//    PULONGLONG rgSymHash;
//    LONG cHashElt;
//    CClfsBaseFile* pBaseFile;
//} CLFSHASHTBL, * PCLFSHASHTBL;





//控制元数据块
typedef struct _MetaBlockControl {
	CLFS_LOG_BLOCK_HEADER logBlockHeader;  //日志块头
	CLFS_CONTROL_RECORD controlRecord;  //控制记录
}MetaBlockControl, * PMETABLOCKCONTROL;

typedef struct _MBC {
	PMETABLOCKCONTROL pMetaBlockControl;
	ULONG size;
}MBC, * PMBC;


//通用元数据块
typedef struct _MetaBlockGeneral {
	CLFS_LOG_BLOCK_HEADER logBlockHeader;  //日志块头
	CLFS_BASE_RECORD_HEADER baseRecordHeader; //基本记录头
}MetaBlockGeneral, * PMETABLOCKGENERAL;

typedef struct _MBG {
	PMETABLOCKGENERAL pMetaBlockGeneral;
	ULONG size;
}MBG, * PMBG;


//临时元数据块
typedef struct _MetaBlockScratch {
	CLFS_LOG_BLOCK_HEADER logBlockHeader;  //日志块头
	CLFS_TRUNCATE_RECORD_HEADER truncateRecoreHeader; //截断记录头
}MetaBlockScratch, * PMETABLOCKSCRATCH;


typedef struct _MBS {
	PMETABLOCKSCRATCH pMetaBlockScratch;
	ULONG size;
}MBS, * PMBS;







#endif